# Machine_learning_code_with_python

只使用python来实现机器学习常见的算法（不借助sklearn等包），主要参考西瓜熟和统计机器学习这两本书，代码有一些是参考了网上其他
人的，我都会在里面注释。欢迎大家给个star或者来提pr，也欢迎大家一起交流。


[![MIT license](https://img.shields.io/dub/l/vibe-d.svg)](https://github.com/lawlite19/MachineLearning_Python/blob/master/LICENSE)


## 目录
* [机器学习算法Python实现](#机器学习算法python实现)
	* [一、Linear_Regression](#一Linear_Regression)
	* [二、PCA](#二PCA)
    * [三、Navie_Bayes](#三Navie_Bayes)
    * [四、SVM](#四SVM)
    * [五、KNN](#五KNN)
    * [六、KMeans](#六KMeans)
    * [七、Decision_Tree](#七Decision_Tree)
    * [八、Logistic_Regression](#八Logistic_Regression)
    * [九、LDA](#九Linear_Discriminant_Analysis)
    * [十、EM](#十EM)
    

## 一、[Linear_Regression](/Linear_Regression)
- [全部代码](/Linear_Regression/linearRegression.ipynb)
- [算法推导](/Linear_Regression/README.md)  
##### 优点：
1、算法简单，可解释性强；  
     
##### 缺点：
1、需要严格的假设；  
2、需处理异常值，对异常值很敏感，对输入数据差；  

##### 适用场景：
自变量和因变量之间是线性关系，适用于low dimension， 而且每一维之间都没有共线性。


## 二、[PCA](/PCA)
- [全部代码](/PCA/PCA.ipynb)
- [算法推导](/PCA/README.md)
##### 优点：
1、可处理大规模数据集；  
2、无需在数据上进行假设；  

##### 缺点：
1、难以搞定非线性数据；
2、难以理解结果的意义；  

##### 适用场景：
维度过高的时候可以用来降低维度。  



## 三、[Navie_Bayes](/Navie_Bayes)
- [全部代码](/Navie_Bayes/navieBayes.ipynb)
- [算法推导](/Navie_Bayes/README.md)
##### 优点：
1、快速、易于训练、给出了它们所需的资源能带来良好的表现；

##### 缺点：
1、如果输入变量是相关的，则精度会出现一定幅度的下降；

##### 适用场景：
需要一个比较容易解释，而且不同维度之间相关性较小的模型的时候。可以高效处理高维数据，虽然结果可能不尽如人意。



## 四、[SVM](/SVM)
- [全部代码](/SVM/SVM.ipynb)（TODO）
- [算法推导](/SVM/README.md)
##### 优点：
1、在非线性可分问题上表现优秀；  
2、SVM 的最终决策函数只由少数的支持向量所确定,计算的复杂性取决于支持向量的数目,而不是样本空间的维数,这在某种意义上避免了“维数灾难”。  
3、少数支持向量决定了最终结果,这不但可以帮助我们抓住关键样本、“剔除”大量冗余样本,而且注定了该方法不但算法简单,而且具有较好的“鲁棒”性。这种“鲁棒”性主要体现在: 
①增、删非支持向量样本对模型没有影响; ②支持向量样本集具有一定的鲁棒性; ③有些成功的应用中,SVM 方法对核的选取不敏感；  
4、它基于结构风险最小化原则，这样就避免了过学习问题，泛化能力强；  
5、它是一个凸优化问题，因此局部最优解一定是全局最优解的优点；  
6、泛华错误率低，分类速度快，结果易解释；  

##### 缺点：
1、大规模的训练样本比较难训练。SVM的空间消耗主要是存储训练样本和核矩阵，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。  
2、对缺失数据敏感，对参数和核函数的选择敏感；  

##### 适用场景：
SVM在很多数据集上都有优秀的表现。相对来说，SVM尽量保持与样本间距离的性质导致它抗攻击的能力更强。和随机森林一样，这也是一个拿到数据就可以先尝试一下的算法。



## 五、[KNN](/KNN)
- [全部代码](/KNN/KNN.ipynb)
- [算法推导](/KNN/README.md)（TODO）
##### 优点：
1、算法简单，可解释性强；  
2、可以生成任意形状的决策边界，因此在分割线比较模糊的分类问题上表现也能不错；
     
##### 缺点：
1、内存消耗高；计算成本高；  
2、不可能用于高维特征空间；  
3、数据量不能过少，否则会因样本数量过少或（和）特征数量过多而导致维度灾难：无法满足密采样条件（样本稀疏问题：维度越高，填充空间所需的数据量越多，可能导致无法找到一个“最近”的样本）；计算量太大（高维空间在距离计算上的问题）；  
4、数据量也不能过多，因为其所耗时间和空间随着数据量增大。这是由于基于实例的方法需要把所有的实例数据（训练样本）都打包做成模型（因为它需要计算对所有样本的距离，然后排序取最近的），所谓数据即模型。其它方法只需提交训练得到的模型和参数即可；  

##### 适用场景：
由于KNN训练的代价小(lazy learning不作训练)，KNN或可被用于在线学习(online machine learning)中，即使用新数据不断训练和更新已有模型从而作出更好的预测。
需要一个特别容易解释的模型的时候，比如需要向用户解释原因的推荐算法。


## 六、[KMeans](/KMeans)
- [全部代码](/KMeans/KMeans.ipynb)
- [算法推导](/KMeans/README.md)（TODO）
##### 优点：
1、算法简单，速度快；  
     
##### 缺点：
1、最终结果和初始点的选择有关，容易陷入局部最优。于是有人提出了两种方法，一种是K-means++，一种是二分K-means算法来尽量使K-means达到全局最优；  
2、需要知道K的值
 

##### 适用场景：
1、提前已经知道K的值的时候。如果当我们不知道样本集将要聚成多少个类别的时候，那么这时候不适合用kmeans算法，推荐使用其他方法来聚类，如（hierarchical 或meanshift）；   
2、一般的聚类场景（例如对用户进行分群组等）外，我们还可以用KMeans实现单变量的离散化，因为一般的等频和等距的离散化方法往往会忽略变量中潜在的分布特征，而基于聚类的离散化可以一定程度地保留变量的分布特征；  



## 七、[Decision_Tree](/Decision_Tree)
- [全部代码](/Decision_Tree/decision_Tree.ipynb)
- [算法推导](/Decision_Tree/README.md)（TODO）
##### 优点：
1、总是在沿着特征做切分。随着层层递进，这个划分会越来越细；  
2、虽然生成的树不容易给用户看，但是数据分析的时候，通过观察树的上层结构，能够对分类器的核心思路有一个直观的感受；  
     
##### 缺点：
1、相对容易被攻击的分类器。
这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中；  

##### 适用场景：
因为它能够生成清晰的基于特征(feature)选择不同预测结果的树状结构，数据分析师希望更好的理解手上的数据的时候往往可以使用决策树。同时它也是相对容易被攻击的分类器。
这里的攻击是指人为的改变一些特征，使得分类器判断错误。常见于垃圾邮件躲避检测中。因为决策树最终在底层判断是基于单个条件的，攻击者往往只需要改变很少的特征就可以逃过监测。
受限于它的简单性，决策树更大的用处是作为一些更有用的算法的基石。



## 八、[Logistic_Regression](/Logistic_Regression)
- [全部代码](/Logistic_Regression/logisticRegression.ipynb)
- [算法推导](/Logistic_Regression/README.md)（TODO）  
回归方法的核心就是为函数找到最合适的参数，使得函数的值和样本的值最接近。例如线性回归(Linear regression)就是对于函数f(x)=ax+b，找到最合适的a,b。
LR拟合的就不是线性函数了，它拟合的是一个概率学中的函数，f(x)的值这时候就反映了样本属于这个类的概率。
##### 优点：
1、模型清晰，背后的概率推导经得住推敲；  
2、输出值自然地落在0到1之间，并且有概率意义。https://www.jianshu.com/p/a8d6b40da0cf  
3、参数代表每个特征对输出的影响，可解释性强；  
4、实施简单，非常高效（计算量小、存储占用低），可以在大数据场景中使用；  
5、可以使用online learning的方式更新轻松更新参数，不需要重新训练整个模型；  
6、解决过拟合的方法很多，如L1、L2正则化；  
7、L2正则化就可以解决多重共线性问题；
     
##### 缺点：
1、（特征相关情况）因为它本质上是一个线性的分类器，所以处理不好特征之间相关的情况；  
2、（特征空间）特征空间很大时，性能不好；  
3、（精度）容易欠拟合，精度不高
##### 适用场景：
LR同样是很多分类算法的基础组件，它的好处是输出值自然地落在0到1之间，并且有概率意义。因为它本质上是一个线性的分类器，所以处理不好特征之间相关的情况。虽然效果一般，却胜在模型清晰，
背后的概率学经得住推敲。它拟合出来的参数就代表了每一个特征(feature)对结果的影响。也是一个理解数据的好工具。


## 九、[Linear_Discriminant_Analysis](/LDA)
- [全部代码](/LDA/LDA.ipynb)（TODO）
- [算法推导](/LDA/README.md)
##### 优点：

     
##### 缺点：

##### 适用场景：
判别分析适用于高维数据需要降维的情况，自带降维功能使得我们能方便地观察样本分布。它的正确性有数学公式可以证明，所以同样是很经得住推敲的方式。但是它的分类准确率往往不是很高，
所以不是统计系的人就把它作为降维工具用吧。同时注意它是假定样本成正态分布的，所以那种同心圆形的数据就不要尝试了。


## 十、[EM](/EM)
- [全部代码](/EM/EM.ipynb)（TODO）
- [算法推导](/EM/README.md)
##### 优点：

     
##### 缺点：

##### 适用场景：
